"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkalgolia_instantsearch_demo"] = self["webpackChunkalgolia_instantsearch_demo"] || []).push([["vendors-node_modules_algolia_client-common_dist_common_js-node_modules_algolia_requester-brow-fb9592"],{

/***/ "./node_modules/@algolia/client-common/dist/common.js":
/*!************************************************************!*\
  !*** ./node_modules/@algolia/client-common/dist/common.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlgoliaError: () => (/* binding */ AlgoliaError),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   DEFAULT_CONNECT_TIMEOUT_BROWSER: () => (/* binding */ DEFAULT_CONNECT_TIMEOUT_BROWSER),\n/* harmony export */   DEFAULT_CONNECT_TIMEOUT_NODE: () => (/* binding */ DEFAULT_CONNECT_TIMEOUT_NODE),\n/* harmony export */   DEFAULT_READ_TIMEOUT_BROWSER: () => (/* binding */ DEFAULT_READ_TIMEOUT_BROWSER),\n/* harmony export */   DEFAULT_READ_TIMEOUT_NODE: () => (/* binding */ DEFAULT_READ_TIMEOUT_NODE),\n/* harmony export */   DEFAULT_WRITE_TIMEOUT_BROWSER: () => (/* binding */ DEFAULT_WRITE_TIMEOUT_BROWSER),\n/* harmony export */   DEFAULT_WRITE_TIMEOUT_NODE: () => (/* binding */ DEFAULT_WRITE_TIMEOUT_NODE),\n/* harmony export */   DeserializationError: () => (/* binding */ DeserializationError),\n/* harmony export */   DetailedApiError: () => (/* binding */ DetailedApiError),\n/* harmony export */   ErrorWithStackTrace: () => (/* binding */ ErrorWithStackTrace),\n/* harmony export */   IndexAlreadyExistsError: () => (/* binding */ IndexAlreadyExistsError),\n/* harmony export */   IndexNotFoundError: () => (/* binding */ IndexNotFoundError),\n/* harmony export */   IndicesInSameAppError: () => (/* binding */ IndicesInSameAppError),\n/* harmony export */   LogLevelEnum: () => (/* binding */ LogLevelEnum),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   createAlgoliaAgent: () => (/* binding */ createAlgoliaAgent),\n/* harmony export */   createAuth: () => (/* binding */ createAuth),\n/* harmony export */   createBrowserLocalStorageCache: () => (/* binding */ createBrowserLocalStorageCache),\n/* harmony export */   createFallbackableCache: () => (/* binding */ createFallbackableCache),\n/* harmony export */   createIterablePromise: () => (/* binding */ createIterablePromise),\n/* harmony export */   createMemoryCache: () => (/* binding */ createMemoryCache),\n/* harmony export */   createNullCache: () => (/* binding */ createNullCache),\n/* harmony export */   createNullLogger: () => (/* binding */ createNullLogger),\n/* harmony export */   createStatefulHost: () => (/* binding */ createStatefulHost),\n/* harmony export */   createTransporter: () => (/* binding */ createTransporter),\n/* harmony export */   deserializeFailure: () => (/* binding */ deserializeFailure),\n/* harmony export */   deserializeSuccess: () => (/* binding */ deserializeSuccess),\n/* harmony export */   getAlgoliaAgent: () => (/* binding */ getAlgoliaAgent),\n/* harmony export */   isNetworkError: () => (/* binding */ isNetworkError),\n/* harmony export */   isRetryable: () => (/* binding */ isRetryable),\n/* harmony export */   isSuccess: () => (/* binding */ isSuccess),\n/* harmony export */   serializeData: () => (/* binding */ serializeData),\n/* harmony export */   serializeHeaders: () => (/* binding */ serializeHeaders),\n/* harmony export */   serializeQueryParameters: () => (/* binding */ serializeQueryParameters),\n/* harmony export */   serializeUrl: () => (/* binding */ serializeUrl),\n/* harmony export */   shuffle: () => (/* binding */ shuffle),\n/* harmony export */   stackFrameWithoutCredentials: () => (/* binding */ stackFrameWithoutCredentials),\n/* harmony export */   stackTraceWithoutCredentials: () => (/* binding */ stackTraceWithoutCredentials)\n/* harmony export */ });\n// src/cache/createBrowserLocalStorageCache.ts\nfunction createBrowserLocalStorageCache(options) {\n  let storage;\n  const namespaceKey = `algolia-client-js-${options.key}`;\n  function getStorage() {\n    if (storage === void 0) {\n      storage = options.localStorage || window.localStorage;\n    }\n    return storage;\n  }\n  function getNamespace() {\n    return JSON.parse(getStorage().getItem(namespaceKey) || \"{}\");\n  }\n  function setNamespace(namespace) {\n    getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n  }\n  function removeOutdatedCacheItems() {\n    const timeToLive = options.timeToLive ? options.timeToLive * 1e3 : null;\n    const namespace = getNamespace();\n    const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(\n      Object.entries(namespace).filter(([, cacheItem]) => {\n        return cacheItem.timestamp !== void 0;\n      })\n    );\n    setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\n    if (!timeToLive) {\n      return;\n    }\n    const filteredNamespaceWithoutExpiredItems = Object.fromEntries(\n      Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem]) => {\n        const currentTimestamp = (/* @__PURE__ */ new Date()).getTime();\n        const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\n        return !isExpired;\n      })\n    );\n    setNamespace(filteredNamespaceWithoutExpiredItems);\n  }\n  return {\n    get(key, defaultValue, events = {\n      miss: () => Promise.resolve()\n    }) {\n      return Promise.resolve().then(() => {\n        removeOutdatedCacheItems();\n        return getNamespace()[JSON.stringify(key)];\n      }).then((value) => {\n        return Promise.all([value ? value.value : defaultValue(), value !== void 0]);\n      }).then(([value, exists]) => {\n        return Promise.all([value, exists || events.miss(value)]);\n      }).then(([value]) => value);\n    },\n    set(key, value) {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n        namespace[JSON.stringify(key)] = {\n          timestamp: (/* @__PURE__ */ new Date()).getTime(),\n          value\n        };\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n        return value;\n      });\n    },\n    delete(key) {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n        delete namespace[JSON.stringify(key)];\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n      });\n    },\n    clear() {\n      return Promise.resolve().then(() => {\n        getStorage().removeItem(namespaceKey);\n      });\n    }\n  };\n}\n\n// src/cache/createNullCache.ts\nfunction createNullCache() {\n  return {\n    get(_key, defaultValue, events = {\n      miss: () => Promise.resolve()\n    }) {\n      const value = defaultValue();\n      return value.then((result) => Promise.all([result, events.miss(result)])).then(([result]) => result);\n    },\n    set(_key, value) {\n      return Promise.resolve(value);\n    },\n    delete(_key) {\n      return Promise.resolve();\n    },\n    clear() {\n      return Promise.resolve();\n    }\n  };\n}\n\n// src/cache/createFallbackableCache.ts\nfunction createFallbackableCache(options) {\n  const caches = [...options.caches];\n  const current = caches.shift();\n  if (current === void 0) {\n    return createNullCache();\n  }\n  return {\n    get(key, defaultValue, events = {\n      miss: () => Promise.resolve()\n    }) {\n      return current.get(key, defaultValue, events).catch(() => {\n        return createFallbackableCache({ caches }).get(key, defaultValue, events);\n      });\n    },\n    set(key, value) {\n      return current.set(key, value).catch(() => {\n        return createFallbackableCache({ caches }).set(key, value);\n      });\n    },\n    delete(key) {\n      return current.delete(key).catch(() => {\n        return createFallbackableCache({ caches }).delete(key);\n      });\n    },\n    clear() {\n      return current.clear().catch(() => {\n        return createFallbackableCache({ caches }).clear();\n      });\n    }\n  };\n}\n\n// src/cache/createMemoryCache.ts\nfunction createMemoryCache(options = { serializable: true }) {\n  let cache = {};\n  return {\n    get(key, defaultValue, events = {\n      miss: () => Promise.resolve()\n    }) {\n      const keyAsString = JSON.stringify(key);\n      if (keyAsString in cache) {\n        return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\n      }\n      const promise = defaultValue();\n      return promise.then((value) => events.miss(value)).then(() => promise);\n    },\n    set(key, value) {\n      cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\n      return Promise.resolve(value);\n    },\n    delete(key) {\n      delete cache[JSON.stringify(key)];\n      return Promise.resolve();\n    },\n    clear() {\n      cache = {};\n      return Promise.resolve();\n    }\n  };\n}\n\n// src/constants.ts\nvar DEFAULT_CONNECT_TIMEOUT_BROWSER = 1e3;\nvar DEFAULT_READ_TIMEOUT_BROWSER = 2e3;\nvar DEFAULT_WRITE_TIMEOUT_BROWSER = 3e4;\nvar DEFAULT_CONNECT_TIMEOUT_NODE = 2e3;\nvar DEFAULT_READ_TIMEOUT_NODE = 5e3;\nvar DEFAULT_WRITE_TIMEOUT_NODE = 3e4;\n\n// src/createAlgoliaAgent.ts\nfunction createAlgoliaAgent(version) {\n  const algoliaAgent = {\n    value: `Algolia for JavaScript (${version})`,\n    add(options) {\n      const addedAlgoliaAgent = `; ${options.segment}${options.version !== void 0 ? ` (${options.version})` : \"\"}`;\n      if (algoliaAgent.value.indexOf(addedAlgoliaAgent) === -1) {\n        algoliaAgent.value = `${algoliaAgent.value}${addedAlgoliaAgent}`;\n      }\n      return algoliaAgent;\n    }\n  };\n  return algoliaAgent;\n}\n\n// src/createAuth.ts\nfunction createAuth(appId, apiKey, authMode = \"WithinHeaders\") {\n  const credentials = {\n    \"x-algolia-api-key\": apiKey,\n    \"x-algolia-application-id\": appId\n  };\n  return {\n    headers() {\n      return authMode === \"WithinHeaders\" ? credentials : {};\n    },\n    queryParameters() {\n      return authMode === \"WithinQueryParameters\" ? credentials : {};\n    }\n  };\n}\n\n// src/createIterablePromise.ts\nfunction createIterablePromise({\n  func,\n  validate,\n  aggregator,\n  error,\n  timeout = () => 0\n}) {\n  const retry = (previousResponse) => {\n    return new Promise((resolve, reject) => {\n      func(previousResponse).then(async (response) => {\n        if (aggregator) {\n          await aggregator(response);\n        }\n        if (await validate(response)) {\n          return resolve(response);\n        }\n        if (error && await error.validate(response)) {\n          return reject(new Error(await error.message(response)));\n        }\n        return setTimeout(\n          () => {\n            retry(response).then(resolve).catch(reject);\n          },\n          await timeout()\n        );\n      }).catch((err) => {\n        reject(err);\n      });\n    });\n  };\n  return retry();\n}\n\n// src/getAlgoliaAgent.ts\nfunction getAlgoliaAgent({ algoliaAgents, client, version }) {\n  const defaultAlgoliaAgent = createAlgoliaAgent(version).add({\n    segment: client,\n    version\n  });\n  algoliaAgents.forEach((algoliaAgent) => defaultAlgoliaAgent.add(algoliaAgent));\n  return defaultAlgoliaAgent;\n}\n\n// src/logger/createNullLogger.ts\nfunction createNullLogger() {\n  return {\n    debug(_message, _args) {\n      return Promise.resolve();\n    },\n    info(_message, _args) {\n      return Promise.resolve();\n    },\n    error(_message, _args) {\n      return Promise.resolve();\n    }\n  };\n}\n\n// src/transporter/createStatefulHost.ts\nvar EXPIRATION_DELAY = 2 * 60 * 1e3;\nfunction createStatefulHost(host, status = \"up\") {\n  const lastUpdate = Date.now();\n  function isUp() {\n    return status === \"up\" || Date.now() - lastUpdate > EXPIRATION_DELAY;\n  }\n  function isTimedOut() {\n    return status === \"timed out\" && Date.now() - lastUpdate <= EXPIRATION_DELAY;\n  }\n  return { ...host, status, lastUpdate, isUp, isTimedOut };\n}\n\n// src/transporter/errors.ts\nvar AlgoliaError = class extends Error {\n  name = \"AlgoliaError\";\n  constructor(message, name) {\n    super(message);\n    if (name) {\n      this.name = name;\n    }\n  }\n};\nvar IndexNotFoundError = class extends AlgoliaError {\n  constructor(indexName) {\n    super(`${indexName} does not exist`, \"IndexNotFoundError\");\n  }\n};\nvar IndicesInSameAppError = class extends AlgoliaError {\n  constructor() {\n    super(\"Indices are in the same application. Use operationIndex instead.\", \"IndicesInSameAppError\");\n  }\n};\nvar IndexAlreadyExistsError = class extends AlgoliaError {\n  constructor(indexName) {\n    super(`${indexName} index already exists.`, \"IndexAlreadyExistsError\");\n  }\n};\nvar ErrorWithStackTrace = class extends AlgoliaError {\n  stackTrace;\n  constructor(message, stackTrace, name) {\n    super(message, name);\n    this.stackTrace = stackTrace;\n  }\n};\nvar RetryError = class extends ErrorWithStackTrace {\n  constructor(stackTrace) {\n    super(\n      \"Unreachable hosts - your application id may be incorrect. If the error persists, please visit our help center https://alg.li/support-unreachable-hosts or reach out to the Algolia Support team: https://alg.li/support\",\n      stackTrace,\n      \"RetryError\"\n    );\n  }\n};\nvar ApiError = class extends ErrorWithStackTrace {\n  status;\n  constructor(message, status, stackTrace, name = \"ApiError\") {\n    super(message, stackTrace, name);\n    this.status = status;\n  }\n};\nvar DeserializationError = class extends AlgoliaError {\n  response;\n  constructor(message, response) {\n    super(message, \"DeserializationError\");\n    this.response = response;\n  }\n};\nvar DetailedApiError = class extends ApiError {\n  error;\n  constructor(message, status, error, stackTrace) {\n    super(message, status, stackTrace, \"DetailedApiError\");\n    this.error = error;\n  }\n};\n\n// src/transporter/helpers.ts\nfunction shuffle(array) {\n  const shuffledArray = array;\n  for (let c = array.length - 1; c > 0; c--) {\n    const b = Math.floor(Math.random() * (c + 1));\n    const a = array[c];\n    shuffledArray[c] = array[b];\n    shuffledArray[b] = a;\n  }\n  return shuffledArray;\n}\nfunction serializeUrl(host, path, queryParameters) {\n  const queryParametersAsString = serializeQueryParameters(queryParameters);\n  let url = `${host.protocol}://${host.url}${host.port ? `:${host.port}` : \"\"}/${path.charAt(0) === \"/\" ? path.substring(1) : path}`;\n  if (queryParametersAsString.length) {\n    url += `?${queryParametersAsString}`;\n  }\n  return url;\n}\nfunction serializeQueryParameters(parameters) {\n  return Object.keys(parameters).filter((key) => parameters[key] !== void 0).sort().map(\n    (key) => `${key}=${encodeURIComponent(\n      Object.prototype.toString.call(parameters[key]) === \"[object Array]\" ? parameters[key].join(\",\") : parameters[key]\n    ).replace(/\\+/g, \"%20\")}`\n  ).join(\"&\");\n}\nfunction serializeData(request, requestOptions) {\n  if (request.method === \"GET\" || request.data === void 0 && requestOptions.data === void 0) {\n    return void 0;\n  }\n  const data = Array.isArray(request.data) ? request.data : { ...request.data, ...requestOptions.data };\n  return JSON.stringify(data);\n}\nfunction serializeHeaders(baseHeaders, requestHeaders, requestOptionsHeaders) {\n  const headers = {\n    Accept: \"application/json\",\n    ...baseHeaders,\n    ...requestHeaders,\n    ...requestOptionsHeaders\n  };\n  const serializedHeaders = {};\n  Object.keys(headers).forEach((header) => {\n    const value = headers[header];\n    serializedHeaders[header.toLowerCase()] = value;\n  });\n  return serializedHeaders;\n}\nfunction deserializeSuccess(response) {\n  try {\n    return JSON.parse(response.content);\n  } catch (e) {\n    throw new DeserializationError(e.message, response);\n  }\n}\nfunction deserializeFailure({ content, status }, stackFrame) {\n  try {\n    const parsed = JSON.parse(content);\n    if (\"error\" in parsed) {\n      return new DetailedApiError(parsed.message, status, parsed.error, stackFrame);\n    }\n    return new ApiError(parsed.message, status, stackFrame);\n  } catch {\n  }\n  return new ApiError(content, status, stackFrame);\n}\n\n// src/transporter/responses.ts\nfunction isNetworkError({ isTimedOut, status }) {\n  return !isTimedOut && ~~status === 0;\n}\nfunction isRetryable({ isTimedOut, status }) {\n  return isTimedOut || isNetworkError({ isTimedOut, status }) || ~~(status / 100) !== 2 && ~~(status / 100) !== 4;\n}\nfunction isSuccess({ status }) {\n  return ~~(status / 100) === 2;\n}\n\n// src/transporter/stackTrace.ts\nfunction stackTraceWithoutCredentials(stackTrace) {\n  return stackTrace.map((stackFrame) => stackFrameWithoutCredentials(stackFrame));\n}\nfunction stackFrameWithoutCredentials(stackFrame) {\n  const modifiedHeaders = stackFrame.request.headers[\"x-algolia-api-key\"] ? { \"x-algolia-api-key\": \"*****\" } : {};\n  return {\n    ...stackFrame,\n    request: {\n      ...stackFrame.request,\n      headers: {\n        ...stackFrame.request.headers,\n        ...modifiedHeaders\n      }\n    }\n  };\n}\n\n// src/transporter/createTransporter.ts\nfunction createTransporter({\n  hosts,\n  hostsCache,\n  baseHeaders,\n  logger,\n  baseQueryParameters,\n  algoliaAgent,\n  timeouts,\n  requester,\n  requestsCache,\n  responsesCache\n}) {\n  async function createRetryableOptions(compatibleHosts) {\n    const statefulHosts = await Promise.all(\n      compatibleHosts.map((compatibleHost) => {\n        return hostsCache.get(compatibleHost, () => {\n          return Promise.resolve(createStatefulHost(compatibleHost));\n        });\n      })\n    );\n    const hostsUp = statefulHosts.filter((host) => host.isUp());\n    const hostsTimedOut = statefulHosts.filter((host) => host.isTimedOut());\n    const hostsAvailable = [...hostsUp, ...hostsTimedOut];\n    const compatibleHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable : compatibleHosts;\n    return {\n      hosts: compatibleHostsAvailable,\n      getTimeout(timeoutsCount, baseTimeout) {\n        const timeoutMultiplier = hostsTimedOut.length === 0 && timeoutsCount === 0 ? 1 : hostsTimedOut.length + 3 + timeoutsCount;\n        return timeoutMultiplier * baseTimeout;\n      }\n    };\n  }\n  async function retryableRequest(request, requestOptions, isRead = true) {\n    const stackTrace = [];\n    const data = serializeData(request, requestOptions);\n    const headers = serializeHeaders(baseHeaders, request.headers, requestOptions.headers);\n    const dataQueryParameters = request.method === \"GET\" ? {\n      ...request.data,\n      ...requestOptions.data\n    } : {};\n    const queryParameters = {\n      ...baseQueryParameters,\n      ...request.queryParameters,\n      ...dataQueryParameters\n    };\n    if (algoliaAgent.value) {\n      queryParameters[\"x-algolia-agent\"] = algoliaAgent.value;\n    }\n    if (requestOptions && requestOptions.queryParameters) {\n      for (const key of Object.keys(requestOptions.queryParameters)) {\n        if (!requestOptions.queryParameters[key] || Object.prototype.toString.call(requestOptions.queryParameters[key]) === \"[object Object]\") {\n          queryParameters[key] = requestOptions.queryParameters[key];\n        } else {\n          queryParameters[key] = requestOptions.queryParameters[key].toString();\n        }\n      }\n    }\n    let timeoutsCount = 0;\n    const retry = async (retryableHosts, getTimeout) => {\n      const host = retryableHosts.pop();\n      if (host === void 0) {\n        throw new RetryError(stackTraceWithoutCredentials(stackTrace));\n      }\n      const timeout = { ...timeouts, ...requestOptions.timeouts };\n      const payload = {\n        data,\n        headers,\n        method: request.method,\n        url: serializeUrl(host, request.path, queryParameters),\n        connectTimeout: getTimeout(timeoutsCount, timeout.connect),\n        responseTimeout: getTimeout(timeoutsCount, isRead ? timeout.read : timeout.write)\n      };\n      const pushToStackTrace = (response2) => {\n        const stackFrame = {\n          request: payload,\n          response: response2,\n          host,\n          triesLeft: retryableHosts.length\n        };\n        stackTrace.push(stackFrame);\n        return stackFrame;\n      };\n      const response = await requester.send(payload);\n      if (isRetryable(response)) {\n        const stackFrame = pushToStackTrace(response);\n        if (response.isTimedOut) {\n          timeoutsCount++;\n        }\n        logger.info(\"Retryable failure\", stackFrameWithoutCredentials(stackFrame));\n        await hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? \"timed out\" : \"down\"));\n        return retry(retryableHosts, getTimeout);\n      }\n      if (isSuccess(response)) {\n        return deserializeSuccess(response);\n      }\n      pushToStackTrace(response);\n      throw deserializeFailure(response, stackTrace);\n    };\n    const compatibleHosts = hosts.filter(\n      (host) => host.accept === \"readWrite\" || (isRead ? host.accept === \"read\" : host.accept === \"write\")\n    );\n    const options = await createRetryableOptions(compatibleHosts);\n    return retry([...options.hosts].reverse(), options.getTimeout);\n  }\n  function createRequest(request, requestOptions = {}) {\n    const isRead = request.useReadTransporter || request.method === \"GET\";\n    if (!isRead) {\n      return retryableRequest(request, requestOptions, isRead);\n    }\n    const createRetryableRequest = () => {\n      return retryableRequest(request, requestOptions);\n    };\n    const cacheable = requestOptions.cacheable || request.cacheable;\n    if (cacheable !== true) {\n      return createRetryableRequest();\n    }\n    const key = {\n      request,\n      requestOptions,\n      transporter: {\n        queryParameters: baseQueryParameters,\n        headers: baseHeaders\n      }\n    };\n    return responsesCache.get(\n      key,\n      () => {\n        return requestsCache.get(\n          key,\n          () => (\n            /**\n             * Finally, if there is no request in progress with the same key,\n             * this `createRetryableRequest()` will actually trigger the\n             * retryable request.\n             */\n            requestsCache.set(key, createRetryableRequest()).then(\n              (response) => Promise.all([requestsCache.delete(key), response]),\n              (err) => Promise.all([requestsCache.delete(key), Promise.reject(err)])\n            ).then(([_, response]) => response)\n          )\n        );\n      },\n      {\n        /**\n         * Of course, once we get this response back from the server, we\n         * tell response cache to actually store the received response\n         * to be used later.\n         */\n        miss: (response) => responsesCache.set(key, response)\n      }\n    );\n  }\n  return {\n    hostsCache,\n    requester,\n    timeouts,\n    logger,\n    algoliaAgent,\n    baseHeaders,\n    baseQueryParameters,\n    hosts,\n    request: createRequest,\n    requestsCache,\n    responsesCache\n  };\n}\n\n// src/types/logger.ts\nvar LogLevelEnum = {\n  Debug: 1,\n  Info: 2,\n  Error: 3\n};\n\n//# sourceMappingURL=common.js.map\n\n//# sourceURL=webpack://algolia-instantsearch-demo/./node_modules/@algolia/client-common/dist/common.js?\n}");

/***/ }),

/***/ "./node_modules/@algolia/requester-browser-xhr/dist/requester.xhr.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@algolia/requester-browser-xhr/dist/requester.xhr.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createXhrRequester: () => (/* binding */ m)\n/* harmony export */ });\nfunction m(){function r(t){return new Promise(s=>{let e=new XMLHttpRequest;e.open(t.method,t.url,!0),Object.keys(t.headers).forEach(n=>e.setRequestHeader(n,t.headers[n]));let i=(n,a)=>setTimeout(()=>{e.abort(),s({status:0,content:a,isTimedOut:!0})},n),u=i(t.connectTimeout,\"Connection timeout\"),o;e.onreadystatechange=()=>{e.readyState>e.OPENED&&o===void 0&&(clearTimeout(u),o=i(t.responseTimeout,\"Socket timeout\"))},e.onerror=()=>{e.status===0&&(clearTimeout(u),clearTimeout(o),s({content:e.responseText||\"Network request failed\",status:e.status,isTimedOut:!1}))},e.onload=()=>{clearTimeout(u),clearTimeout(o),s({content:e.responseText,status:e.status,isTimedOut:!1})},e.send(t.data)})}return{send:r}}\n//# sourceMappingURL=requester.xhr.js.map\n\n//# sourceURL=webpack://algolia-instantsearch-demo/./node_modules/@algolia/requester-browser-xhr/dist/requester.xhr.js?\n}");

/***/ })

}]);